import dash
from dash import html, dcc
from dash import dash_table
from dash import Input, Output, callback, no_update, State, ALL
from mylibrary import *
import yaml
import os
import time
import gc
import json
import pandas as pd
import pytz

# Configuration cache for stats page with size limit
_stats_config_cache = {}
_stats_config_cache_timestamp = 0
_stats_config_cache_ttl = 300  # 5 seconds cache TTL
_stats_config_cache_max_size = 10  # Limit cache size



def load_config():
    """Load configuration from YAML file with caching"""
    global _stats_config_cache, _stats_config_cache_timestamp

    current_time = time.time()
    if (not _stats_config_cache or
        current_time - _stats_config_cache_timestamp > _stats_config_cache_ttl):

        config_path = os.path.join(os.path.dirname(__file__), '..', 'config.yaml')
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                _stats_config_cache = yaml.safe_load(f) or {}
            _stats_config_cache_timestamp = current_time

            # Limit cache size
            if len(_stats_config_cache) > _stats_config_cache_max_size:
                # Keep only the most recent entries
                keys = list(_stats_config_cache.keys())[:_stats_config_cache_max_size]
                _stats_config_cache = {k: _stats_config_cache[k] for k in keys}
        except (FileNotFoundError, Exception):
            _stats_config_cache = {}
            _stats_config_cache_timestamp = current_time

    return _stats_config_cache

def load_core_config():
    """Load core configuration from cached config"""
    config = load_config()
    return config.get('core', {})

# Cache for CI metadata loaded from TimescaleDB
_ci_meta_cache = None
_ci_meta_cache_timestamp = 0
_ci_meta_cache_ttl = 300  # 5 minutes cache TTL

def load_ci_metadata_map():
    """Load CI -> {name, organization, product} map from TimescaleDB with caching."""
    global _ci_meta_cache, _ci_meta_cache_timestamp

    current_time = time.time()
    if (_ci_meta_cache is not None and
        current_time - _ci_meta_cache_timestamp < _ci_meta_cache_ttl):
        return _ci_meta_cache

    try:
        # Get CI metadata directly from TimescaleDB
        with get_db_conn() as conn:
            query = """
            SELECT ci, name, organization, product
            FROM ci_metadata
            ORDER BY ci
            """
            with conn.cursor() as cur:
                cur.execute(query)
                results = cur.fetchall()

        # Create mapping
        mapping = {}
        for row in results:
            ci, name, organization, product = row
            mapping[str(ci)] = {
                'name': name or '',
                'organization': organization or '',
                'product': product or ''
            }

        _ci_meta_cache = mapping
        _ci_meta_cache_timestamp = current_time
        return mapping

    except Exception as e:
        print(f"Error loading CI metadata from TimescaleDB: {e}")
        return _ci_meta_cache or {}

def get_cached_statistics(config_file_name, cis):
    """Get statistics from JSON file (generated by cron.py) or calculate them if file doesn't exist"""

    # Try to load statistics from JSON file first
    statistics_file_path = os.path.join(os.path.dirname(__file__), '..', 'data', 'statistics.json')

    try:
        if os.path.exists(statistics_file_path):
            with open(statistics_file_path, 'r', encoding='utf-8') as f:
                file_stats = json.load(f)

            # Check if the file has valid statistics
            if file_stats and 'calculated_at' in file_stats:
                file_age = time.time() - file_stats['calculated_at']
                print(f"Using statistics from file (age: {file_age:.1f}s)")

                # Convert timestamp strings back to datetime objects for display
                if file_stats.get('latest_timestamp'):
                    file_stats['latest_timestamp'] = pd.to_datetime(file_stats['latest_timestamp'])
                if file_stats.get('earliest_timestamp'):
                    file_stats['earliest_timestamp'] = pd.to_datetime(file_stats['earliest_timestamp'])

                # Convert product_counts and organization_counts back to pandas Series
                if file_stats.get('product_counts'):
                    file_stats['product_counts'] = pd.Series(file_stats['product_counts'])
                if file_stats.get('organization_counts'):
                    file_stats['organization_counts'] = pd.Series(file_stats['organization_counts'])

                # Ensure overall_availability_percentage_total exists (fallback to overall_availability_percentage)
                if 'overall_availability_percentage_total' not in file_stats:
                    file_stats['overall_availability_percentage_total'] = file_stats.get('overall_availability_percentage', 0)

                # Recalculate data age dynamically based on current time
                if file_stats.get('latest_timestamp'):
                    current_time = pd.Timestamp.now(tz=pytz.timezone('Europe/Berlin'))
                    data_age_hours = (current_time - file_stats['latest_timestamp']).total_seconds() / 3600
                    file_stats['data_age_formatted'] = format_duration(data_age_hours)

                # Ensure top_unstable_cis_by_incidents exists (map from top_unstable_cis)
                if 'top_unstable_cis_by_incidents' not in file_stats and 'top_unstable_cis' in file_stats:
                    file_stats['top_unstable_cis_by_incidents'] = file_stats['top_unstable_cis']

                # Debug: Print key statistics to verify they are loaded correctly
                print(f"DEBUG: Loaded statistics - uptime: {file_stats.get('overall_uptime_minutes', 'NOT_FOUND')}, downtime: {file_stats.get('overall_downtime_minutes', 'NOT_FOUND')}, mttr: {file_stats.get('mttr_minutes_mean', 'NOT_FOUND')}")
                print(f"DEBUG: Loaded CI data - count: {len(file_stats.get('top_unstable_cis_by_incidents', []))}")

                return file_stats
    except Exception as e:
        print(f"Error loading statistics from file: {e}")

    # Fallback: calculate statistics if file doesn't exist or is invalid
    print("Statistics file not available, calculating new statistics")

    # Check if TimescaleDB is enabled
    config = load_config()
    use_timescaledb = config.get('core', {}).get('timescaledb', {}).get('enabled', False)

    if use_timescaledb:
        print("Using TimescaleDB for statistics calculation...")
        # Import the TimescaleDB statistics function from mylibrary
        try:
            import mylibrary
            new_stats = mylibrary.get_timescaledb_statistics_data()
            if new_stats:
                return new_stats
        except Exception as e:
            print(f"Error calculating TimescaleDB statistics: {e}")

    # Final fallback: use HDF5-based calculation
    new_stats = calculate_overall_statistics(config_file_name, cis)
    return new_stats



def format_duration(hours):
    """Format duration in a human-readable way"""
    if hours < 1:
        minutes = int(hours * 60)
        return f"{minutes} Minuten"
    elif hours < 24:
        return f"{hours:.1f} Stunden"
    else:
        days = hours / 24
        return f"{days:.1f} Tage"

def truncate_organization(org_name, max_length=40):
    """Truncate organization name if too long"""
    if not org_name:
        return ""
    if len(org_name) <= max_length:
        return org_name
    return org_name[:max_length-3] + "..."

def calculate_overall_statistics(config_file_name, cis):
    """
    Calculate overall statistics for all Configuration Items including:
    - Total counts and current availability
    - Overall availability percentage
    - Recording time range
    - Product distribution
    - Organization distribution
    """
    if cis.empty:
        return {}

    # Basic counts
    total_cis = len(cis)
    currently_available = cis['current_availability'].sum()
    currently_unavailable = total_cis - currently_available
    overall_availability_percentage = (currently_available / total_cis) * 100 if total_cis > 0 else 0

    # Product distribution
    product_counts = cis['product'].value_counts()
    total_products = len(product_counts)

    # Organization distribution
    organization_counts = cis['organization'].value_counts()
    total_organizations = len(organization_counts)

    # Current status distribution
    status_counts = cis['current_availability'].value_counts()
    available_count = status_counts.get(1, 0)
    unavailable_count = status_counts.get(0, 0)

    # Recent changes (availability_difference != 0)
    recent_changes = cis[cis['availability_difference'] != 0]
    changes_count = len(recent_changes)

    # Get overall recording time range (from the most recent timestamp)
    latest_timestamp = None
    earliest_timestamp = None
    data_age_formatted = "Unbekannt"
    total_recording_minutes = 0

    # Try to get timestamps from different possible columns in general data
    timestamp_columns = ['time', 'timestamp', 'created_at', 'updated_at']
    for col in timestamp_columns:
        if col in cis.columns and not cis[col].isna().all():
            try:
                latest_timestamp = pd.to_datetime(cis[col].max())
                earliest_timestamp = pd.to_datetime(cis[col].min())

                # Ensure both timestamps have timezone info and are in Europe/Berlin
                if latest_timestamp.tz is None:
                    latest_timestamp = latest_timestamp.tz_localize('Europe/Berlin')
                elif latest_timestamp.tz != pytz.timezone('Europe/Berlin'):
                    latest_timestamp = latest_timestamp.tz_convert('Europe/Berlin')

                if earliest_timestamp.tz is None:
                    earliest_timestamp = earliest_timestamp.tz_localize('Europe/Berlin')
                elif earliest_timestamp.tz != pytz.timezone('Europe/Berlin'):
                    earliest_timestamp = earliest_timestamp.tz_convert('Europe/Berlin')

                # Get current time in Europe/Berlin
                current_time = pd.Timestamp.now(tz=pytz.timezone('Europe/Berlin'))
                data_age_hours = (current_time - latest_timestamp).total_seconds() / 3600
                data_age_formatted = format_duration(data_age_hours)

                # Calculate total recording time from the overall time range
                total_recording_minutes = (latest_timestamp - earliest_timestamp).total_seconds() / 60
                print(f"Total recording time from general data: {earliest_timestamp} to {latest_timestamp} = {total_recording_minutes:.1f} minutes")
                break
            except Exception as e:
                print(f"Error processing timestamp column {col}: {e}")
                continue

    return {
        'total_cis': total_cis,
        'currently_available': currently_available,
        'currently_unavailable': currently_unavailable,
        'overall_availability_percentage': overall_availability_percentage,
        'overall_availability_percentage_total': overall_availability_percentage,  # Same as current availability for now
        'total_products': total_products,
        'total_organizations': total_organizations,
        'available_count': available_count,
        'unavailable_count': unavailable_count,
        'changes_count': changes_count,
        'latest_timestamp': latest_timestamp,
        'earliest_timestamp': earliest_timestamp,
        'data_age_formatted': data_age_formatted,
        'product_counts': product_counts,
        'organization_counts': organization_counts,
        'total_recording_minutes': total_recording_minutes
    }

dash.register_page(__name__, path='/stats')

def create_overall_statistics_display(stats):
    """Create the overall statistics display section"""
    children = [
        html.H3('ðŸ“Š Gesamtstatistik aller Configuration Items'),

        # Main overview - 2 column responsive grid
        html.Div(className='stats-overview stats-two-columns', children=[
            html.Div(className='stat-card', children=[
                html.H4('ðŸŽ¯ Ãœbersicht'),
                html.Div(className='stat-grid', children=[
                    html.Div(className='stat-item', children=[
                        html.Strong('Gesamtanzahl CIs: '),
                        html.Span(f'{stats["total_cis"]:,}')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Aktuell verfÃ¼gbar: '),
                        html.Span(f'{stats["currently_available"]:,}')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Aktuell nicht verfÃ¼gbar: '),
                        html.Span(f'{stats["currently_unavailable"]:,}')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('GesamtverfÃ¼gbarkeit (Zeitbasis): ', title='Zeitgewichtete VerfÃ¼gbarkeit Ã¼ber alle CIs im Ã¼berwachten Zeitraum'),
                        html.Span(
                            f"{(stats.get('overall_availability_percentage_rollup') or 0):.2f}%",
                            title='Zeitgewichtete VerfÃ¼gbarkeit Ã¼ber alle CIs im Ã¼berwachten Zeitraum'
                        )
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Gesamtdauer Aufzeichnung: '),
                        html.Span(format_duration(stats["total_recording_minutes"] / 60) if stats.get("total_recording_minutes", 0) > 0 else 'Unbekannt')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Kumulative Uptime (Ã¼ber alle CIs): ', title='Summe der Betriebszeiten aller CIs im Zeitraum'),
                        html.Span(
                            format_duration((stats.get('overall_uptime_minutes') or 0) / 60),
                            title='Summe der Betriebszeiten aller CIs im Zeitraum'
                        )
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Ã˜ Uptime pro CI im Zeitraum: ', title='Durchschnittliche Betriebszeit je CI im Zeitraum'),
                        html.Span(
                            format_duration(
                                (
                                    ((stats.get('overall_uptime_minutes') or 0) / max(1, int(stats.get('total_cis', 0))))
                                ) / 60
                            ),
                            title='Durchschnittliche Betriebszeit je CI im Zeitraum'
                        )
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Gesamte Downtime: '),
                        html.Span(format_duration((stats.get('overall_downtime_minutes') or 0) / 60))
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Incidents (gesamt): ', title='Anzahl AusfÃ¤lle (ÃœbergÃ¤nge von verfÃ¼gbar zu nicht verfÃ¼gbar)'),
                        html.Span(f"{int(stats.get('total_incidents', 0))}", title='Anzahl AusfÃ¤lle (ÃœbergÃ¤nge von verfÃ¼gbar zu nicht verfÃ¼gbar)')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('MTTR (Ã˜, Minuten): ', title='Mean Time To Repair â€“ durchschnittliche Dauer eines Ausfalls bis zur Wiederherstellung'),
                        html.Span(f"{(stats.get('mttr_minutes_mean') or 0):.1f}", title='Mean Time To Repair â€“ durchschnittliche Dauer eines Ausfalls bis zur Wiederherstellung')
                    ]),

                ])
            ]),

            html.Div(className='stat-card', children=[
                html.H4('ðŸ“… Datenstatus'),
                html.Div(className='stat-grid', children=[
                    html.Div(className='stat-item', children=[
                        html.Strong('Letzte Aktualisierung: '),
                        html.Span(
                            pd.to_datetime(stats.get("last_updated", stats.get("latest_timestamp", ""))).tz_convert('Europe/Berlin').strftime('%d.%m.%Y %H:%M:%S Uhr')
                            if stats.get("last_updated", stats.get("latest_timestamp", "")) else 'Unbekannt'
                        )
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('NÃ¤chste Aktualisierung: '),
                        html.Span(
                            (pd.to_datetime(stats.get("last_updated", stats.get("latest_timestamp", ""))).tz_convert('Europe/Berlin') + pd.Timedelta(hours=1)).strftime('%d.%m.%Y %H:%M:%S Uhr')
                            if stats.get("last_updated", stats.get("latest_timestamp", "")) else 'Unbekannt'
                        )
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Datenalter: '),
                        html.Span(stats.get("data_age_formatted", "Unbekannt"))
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('KÃ¼rzliche Ã„nderungen: '),
                        html.Span(f'{stats.get("changes_count", 0):,}')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('DatenbankgrÃ¶ÃŸe: '),
                        html.Span(f'{stats.get("database_size_mb", 0):.1f} MB')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Gesamtanzahl Datenpunkte: '),
                        html.Span(f"{int(stats.get('total_datapoints', 0)):,}")
                    ])
                ])
            ]),



        ])
    ]

    # Entfernt: doppelte Gesamtstatistik (zeitgewichtete VerfÃ¼gbarkeit & Aufzeichnungszeit)





    return html.Div(className='overall-statistics box', children=children)

def serve_layout():
    # Load core configurations (now cached)
    core_config = load_core_config()

    # TimescaleDB mode - no file_name needed
    config_file_name = None
    config_url = core_config.get('url')

    # Try to get data from TimescaleDB
    try:
        cis = get_data_of_all_cis_from_timescaledb()
    except Exception as e:
        print(f"Error reading data from TimescaleDB: {e}")
        cis = pd.DataFrame()  # Empty DataFrame

    # Check if DataFrame is empty
    if cis.empty:
        # Try to load data from API if URL is available
        if config_url:
            try:
                print(f"Loading data from API: {config_url}")
                update_file(config_file_name, config_url)
                # Try to read data again
                cis = get_data_of_all_cis(config_file_name)
                print(f"Loaded {len(cis)} records from API")
            except Exception as e:
                print(f"Error loading data from API: {e}")

        # If still empty, show message
        if cis.empty:
            layout = html.Div([
                html.P('Keine Daten verfÃ¼gbar. Versuche Daten von der API zu laden...'),
                html.P('Falls das Problem weiterhin besteht, Ã¼berprÃ¼fen Sie die API-Verbindung.'),
                html.P(f'API URL: {config_url or "Nicht konfiguriert"}'),
                html.P(f'Daten-Datei: {config_file_name}')
            ])
            return layout

    # Check if 'product' column exists
    if 'product' not in cis.columns:
        layout = html.Div([
            html.P('Daten sind verfÃ¼gbar, aber die Spalte "product" fehlt. MÃ¶glicherweise ist die Datenstruktur fehlerhaft.'),
            html.P('VerfÃ¼gbare Spalten: ' + ', '.join(cis.columns.tolist())),
            html.P(f'Anzahl DatensÃ¤tze: {len(cis)}')
        ])
        return layout

    # Get statistics from cache or calculate them
    overall_stats = get_cached_statistics(config_file_name, cis)
    # Fallback: wenn Liste leer ist, aus statistics.json nachladen
    try:
        statistics_file_path = os.path.join(os.path.dirname(__file__), '..', 'data', 'statistics.json')
        if not overall_stats.get('top_unstable_cis_by_incidents') and os.path.exists(statistics_file_path):
            with open(statistics_file_path, 'r', encoding='utf-8') as f:
                file_stats = json.load(f)
            overall_stats['top_unstable_cis_by_incidents'] = file_stats.get('top_unstable_cis', [])
    except Exception as e:
        print(f"Warning loading statistics.json fallback: {e}")

    # Force garbage collection after loading large datasets
    gc.collect()

    # Additional cleanup for large DataFrames
    if 'cis' in locals():
        del cis
        gc.collect()

    top_unstable_data = [
        {
            'ci': entry['ci'],
            'name': (
                load_ci_metadata_map().get(str(entry.get('ci', '')), {}).get('name')
                or entry.get('name', '')
            ),
            'organization': truncate_organization(
                (
                    load_ci_metadata_map().get(str(entry.get('ci', '')), {}).get('organization')
                    or entry.get('organization', '')
                )
            ),
            'product': (
                load_ci_metadata_map().get(str(entry.get('ci', '')), {}).get('product')
                or entry.get('product', '')
            ),
            'incidents': int(entry['incidents']),
            'downtime_minutes': round(float(entry.get('downtime_minutes', 0.0))),
            'availability_percentage': round(float(entry.get('availability_percentage', 0.0)), 2),
        }
        for entry in sorted(
            overall_stats.get('top_unstable_cis_by_incidents', []),
            key=lambda entry: (
                float(entry.get('availability_percentage', 0.0)),
                -int(entry['incidents'])
            )
        )
    ]

    layout = html.Div([
        html.P('Hier finden Sie eine umfassende Gesamtstatistik aller Configuration Items. Neue Daten werden stÃ¼ndlich neu berechnet. Laden Sie die Seite ggfs. neu, um die Ansicht zu aktualisieren.'),

        # Top instabile CIs Section (moved to top with filter and sort)
        html.Div([
            html.H3("Top instabile CIs (Incidents)", className='stats-title'),
            dcc.Input(
                id='unstable-cis-filter',
                type='text',
                placeholder='CIs filtern (CI, Organisation, Produkt oder Name)',
                style={
                    'width': '100%',
                    'boxSizing': 'border-box',
                    'marginBottom': '16px',
                    'padding': '10px 14px',
                    'borderRadius': '8px',
                    'backgroundColor': '#ffffff',
                    'color': '#1e293b',
                    'border': '1px solid #cbd5e1',
                    'fontSize': '14px'
                },
                className='incidents-filter-input'
            ),
            dcc.Store(id='unstable-cis-sort-state', data={'by': 'incidents', 'asc': False}),
            dcc.Store(id='unstable-cis-data-store', data=top_unstable_data),
            html.Div(
                id='unstable-cis-table-container',
                className='incidents-table-container',
                style={'maxHeight': '500px', 'overflowY': 'auto'}
            )
        ], className='incidents-section'),

        # Cache information
        html.Div(className='cache-info', children=[
            html.P(f'ðŸ“Š Statistiken werden stÃ¼ndlich von cron.py berechnet und gecacht'),
            html.P(f'ðŸ”„ NÃ¤chste Aktualisierung: StÃ¼ndlich')
        ]),

        # Overall statistics section
        create_overall_statistics_display(overall_stats),

        # Location component for navigation
        dcc.Location(id='stats-location', refresh=False),
    ])

    return layout

layout = serve_layout


def _format_minutes_to_human(minutes: float) -> str:
    try:
        m = float(minutes or 0.0)
        if m < 60:
            return f"{m:.0f} Min"
        h = m / 60.0
        if h < 24:
            return f"{h:.1f} Std"
        d = h / 24.0
        return f"{d:.1f} Tg"
    except Exception:
        return "0 Min"


@callback(
    Output('unstable-cis-table-container', 'children'),
    [Input('unstable-cis-filter', 'value'),
     Input('unstable-cis-sort-state', 'data'),
     Input('unstable-cis-data-store', 'data')],
    prevent_initial_call=False
)
def render_unstable_cis_table(filter_text, sort_state, data):
    try:
        if not data:
            return html.Div('Keine Daten verfÃ¼gbar.')

        df = pd.DataFrame(data)
        if df.empty:
            return html.Div('Keine CIs verfÃ¼gbar.')

        by = (sort_state or {}).get('by', 'incidents')
        asc = bool((sort_state or {}).get('asc', False))

        if by in df.columns:
            df = df.sort_values([by, 'ci'], ascending=[asc, True])
        else:
            df = df.sort_values('incidents', ascending=False)

        if filter_text:
            f = str(filter_text).strip().lower()
            def match_row(r):
                try:
                    return (
                        f in str(r.get('ci', '')).lower()
                        or f in str(r.get('organization', '')).lower()
                        or f in str(r.get('product', '')).lower()
                        or f in str(r.get('name', '')).lower()
                    )
                except Exception:
                    return False
            mask = df.apply(match_row, axis=1)
            df = df[mask]

        rows = []
        for _, row in df.iterrows():
            avail = float(row.get('availability_percentage', 0))
            avail_class = 'available' if avail >= 99.5 else ('impaired' if avail >= 95 else 'unavailable')

            rows.append(
                html.Tr([
                    html.Td([
                        html.A(
                            str(row.get('ci', '')),
                            href=f"/plot?ci={str(row.get('ci', ''))}",
                            className='ci-link'
                        ),
                        html.Br(),
                        html.Span(str(row.get('name', '')), className='ci-name')
                    ]),
                    html.Td([
                        html.Span(str(row.get('organization', '')), className='org-name'),
                        html.Br(),
                        html.Span(str(row.get('product', '')), className='product-name')
                    ]),
                    html.Td(str(int(row.get('incidents', 0))), className='duration', style={'textAlign': 'right'}),
                    html.Td(_format_minutes_to_human(row.get('downtime_minutes')), className='duration'),
                    html.Td(
                        html.Span(f"{avail:.2f}%", className=f'status-badge {avail_class}')
                    )
                ])
            )

        def sort_header(label, col_key, current, min_width=None):
            is_active = (current.get('by') == col_key)
            asc_active = is_active and current.get('asc', False)
            desc_active = is_active and not current.get('asc', False)
            arrow_style_base = {
                'border': 'none',
                'background': 'transparent',
                'cursor': 'pointer',
                'padding': '0 4px',
                'fontSize': '10px',
                'lineHeight': '1'
            }
            asc_style = {**arrow_style_base, 'color': '#0d9488' if asc_active else 'inherit'}
            desc_style = {**arrow_style_base, 'color': '#0d9488' if desc_active else 'inherit'}
            th_style = {
                'whiteSpace': 'nowrap',
                'verticalAlign': 'middle',
                'paddingRight': '8px',
                'paddingLeft': '8px',
                'minWidth': min_width or 'auto'
            }
            return html.Th([
                html.Span(label),
                html.Span([
                    html.Button(
                        'â–²',
                        id={'type': 'unstable-sort', 'col': col_key, 'dir': 'asc'},
                        n_clicks=0,
                        style=asc_style,
                        className='table-sort-btn'
                    ),
                    html.Button(
                        'â–¼',
                        id={'type': 'unstable-sort', 'col': col_key, 'dir': 'desc'},
                        n_clicks=0,
                        style=desc_style,
                        className='table-sort-btn'
                    )
                ], style={'float': 'right', 'display': 'inline-flex', 'gap': '2px'})
            ], style=th_style)

        header = html.Thead([
            html.Tr([
                sort_header('CI', 'ci', sort_state or {}, min_width='140px'),
                sort_header('Organisation Â· Produkt', 'organization', sort_state or {}, min_width='200px'),
                sort_header('Incidents', 'incidents', sort_state or {}, min_width='100px'),
                sort_header('Downtime', 'downtime_minutes', sort_state or {}, min_width='100px'),
                sort_header('VerfÃ¼gbarkeit', 'availability_percentage', sort_state or {}, min_width='120px')
            ])
        ])

        table = html.Table([header, html.Tbody(rows)], className='incidents-table')
        return table

    except Exception as e:
        return html.Div(f'Fehler beim Laden: {str(e)}', style={'color': 'red'})


@callback(
    Output('unstable-cis-sort-state', 'data'),
    Input({'type': 'unstable-sort', 'col': ALL, 'dir': ALL}, 'n_clicks'),
    State('unstable-cis-sort-state', 'data'),
    prevent_initial_call=True
)
def toggle_unstable_sort(_clicks, state):
    ctx = dash.callback_context
    state = state or {'by': 'incidents', 'asc': False}
    if not ctx.triggered:
        return state
    trig = ctx.triggered[0]['prop_id'].split('.')[0]
    try:
        obj = json.loads(trig)
        col = obj.get('col')
        direction = obj.get('dir')
    except Exception:
        return state
    if not col or direction not in ('asc', 'desc'):
        return state
    return {'by': col, 'asc': direction == 'asc'}
